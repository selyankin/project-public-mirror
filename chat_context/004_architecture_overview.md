# Mirano — Architecture Overview (DDD / Modular Monolith)

## 1. Назначение документа

Этот документ описывает **целевую архитектуру Mirano на уровне модулей и слоёв**, принципы взаимодействия компонентов и основные потоки данных.

Цель:

* чтобы любой разработчик или AI-ассистент быстро понял «как это собрано»
* чтобы архитектура была готова к эволюции **в микросервисы** без полной переделки
* чтобы обеспечить контролируемую интеграцию источников, фоновые задачи и воспроизводимость отчётов

Технологический фокус (MVP): **Python + Postgres + Docker**. Остальные технологии считаются заменяемыми деталями.

---

## 2. Архитектурный подход

### 2.1. Стиль: Modular Monolith + DDD

Mirano строится как **модульный монолит**:

* каждый доменный модуль изолирован по коду и зависимостям
* взаимодействие между модулями — через **публичные интерфейсы** (ports) и доменные события
* внутренняя реализация модулей скрыта

Это позволяет:

* быстрее собирать MVP
* сохранить границы (bounded contexts)
* позже выделять модули в микросервисы с минимальными изменениями

### 2.2. Принцип зависимостей

* UI/Transport (API) зависит от Application layer
* Application layer зависит от Domain
* Infrastructure/Adapters зависит от Application/Domain (через ports)

**Domain не зависит ни от чего.**

---

## 3. Слои внутри каждого модуля (DDD)

В каждом модуле используется единый шаблон слоёв:

### 3.1. Domain Layer

* Entities / Value Objects
* Domain services (чистая бизнес-логика)
* Domain events
* Правила и инварианты

### 3.2. Application Layer

* Use cases (команды/запросы)
* Оркестрация процессов
* Транзакционные границы
* DTO/Read models (если нужно)
* Ports (интерфейсы): репозитории, клиенты, шины

### 3.3. Infrastructure / Adapters

* Реализации репозиториев (Postgres)
* HTTP/Parser клиенты источников
* Очереди/воркеры (если используются)
* Интеграции (proxy, rate-limit, кэш)

### 3.4. Transport (API)

* REST (или иной) слой
* Валидация входа
* Маппинг DTO ↔ команды/запросы

---

## 4. Модули системы (bounded contexts)

Ниже — целевой список модулей MVP (возможны объединения, но границы сохраняем).

### 4.1. Identity & Access (User)

**Ответственность:** пользователи, тарифы, доступ к отчётам.

* пользователи (User)
* план/оплата (минимально для MVP)
* права доступа к Report

### 4.2. Property (Core)

**Ответственность:** объект недвижимости и его идентификация.

* Property, Building, ЖК (если нужно)
* нормализованный адрес
* ссылки на внешние идентификаторы (кадастр, фиас и т.д.)

### 4.3. Normalization (Address/Names)

**Ответственность:** приведение входных данных к каноническому виду.

* нормализация адреса (ФИАС)
* нормализация имён/названий (алиасы)

> В MVP модуль может быть частью Property, но как логическая граница он фиксируется.

### 4.4. Sources Gateway (Connectors)

**Ответственность:** единая точка интеграции с внешними источниками.

* стандартизированные клиенты (parsers/scrapers)
* единый контракт результатов
* обработка ошибок источников

Ключевой принцип: внешние источники **никогда** не дергаются напрямую из домена.

### 4.5. Proxy & Network (Proxy)

**Ответственность:** выдача прокси/сетевых профилей для походов в источники.

* пул прокси
* выдача/аренда прокси на время задачи
* базовые правила: ротация, лимиты, healthcheck

Модуль предоставляется как сервис для Sources Gateway.

### 4.6. Discovery & Search (Search)

**Ответственность:** запуск и управление задачами поиска/проверки.

* создание SearchJob по входу пользователя
* разбиение на подзадачи (по источникам)
* трекинг статусов выполнения

### 4.7. Facts & Evidence (Facts)

**Ответственность:** хранение проверяемых фактов и доказательств.

* Fact как атомарный элемент
* Evidence: ссылка на источник, параметры запроса, timestamp
* дедупликация фактов

Факты — основа прозрачности отчёта.

### 4.8. Risk Engine (Risk)

**Ответственность:** интерпретация фактов в категории риска.

* правила/веса
* confidence
* агрегация по категориям

Важно: Risk Engine не «угадывает», а пересчитывает на основании Facts.

### 4.9. Reporting (Report)

**Ответственность:** сборка результатов в RiskCard/PDF.

* генерация RiskCard view-model
* генерация PDF отчёта
* версионирование отчёта (снимок состояния)

---

## 5. Основные потоки (end-to-end)

### 5.1. Поток: Проверка квартиры по адресу (быстрый сценарий)

1. API принимает ввод: адрес (и опционально параметры)
2. Normalization приводит адрес к каноническому виду (ФИАС)
3. Property создаёт/находит Property в БД
4. Search создаёт SearchJob (статус: CREATED)
5. Search запускает подзадачи на источники (async/background)
6. Sources Gateway обращается к источникам, используя Proxy модуль
7. Результаты конвертируются в Facts + Evidence и сохраняются
8. Risk пересчитывает риск по мере поступления фактов
9. Report собирает RiskCard и отдаёт пользователю прогресс/результат

Пользователь может видеть:

* прогресс по источникам
* частичный результат (по готовым источникам)

---

### 5.2. Поток: Платный модульный отчёт

1. Пользователь выбирает расширенный отчёт (доп. источники/глубина)
2. User/Access проверяет доступ/оплату
3. SearchJob создаётся с «профилем отчёта» (набор источников и правил)
4. Выполнение аналогично 5.1
5. Report формирует PDF как итоговый артефакт

---

### 5.3. Поток: Фоновое обновление данных (re-check)

1. Планировщик создаёт фоновые SearchJob для актуализации
2. Для каждого Property определяется «окно обновления»
3. Выполняются источники с учётом TTL/приоритета
4. Новые Facts добавляются/дедуплицируются
5. Risk пересчитывает показатели
6. При значимых изменениях могут формироваться уведомления (future)

---

## 6. Фоновые воркеры и задачи

### 6.1. Общая модель

* есть очередь задач (логически)
* воркер берёт задачу SearchJob/Task
* выполняет обращение к источнику
* пишет результат как Facts/Evidence

### 6.2. Типы задач

* NormalizeAddressTask
* SourceFetchTask (per source)
* ParseAndMapTask
* FactsUpsertTask
* RiskRecalcTask
* ReportBuildTask

В MVP задачи могут быть выполнены одной цепочкой воркера, но контракты сохраняем.

### 6.3. Идемпотентность

Каждая задача должна быть идемпотентна:

* повтор запуска не должен ломать состояние
* дедупликация Fact на уровне ключей
* Evidence хранит параметры запроса для трассируемости

---

## 7. Модель данных (концептуально)

### 7.1. Основные агрегаты

* Property (aggregate root)
* SearchJob (aggregate root)
* Fact (aggregate root или часть Facts контекста)
* Report (aggregate root)

### 7.2. Принципы хранения

* Postgres как основной источник истины
* хранить «сырьё» (raw payload) ограниченно и осознанно (по необходимости)
* хранить нормализованные факты и ссылки на evidence

---

## 8. Взаимодействие модулей (правила)

### 8.1. Разрешённые зависимости (MVP)

* API → Application слои модулей
* Search → Sources Gateway
* Sources Gateway → Proxy
* Sources Gateway → Facts (через порт сохранения)
* Risk → Facts (чтение), Report (чтение)
* Report → Facts + Risk

### 8.2. Запрещённые зависимости

* Domain одного модуля не импортирует Infrastructure другого
* Sources не пишут напрямую в Report
* API не лезет в Infrastructure

---

## 9. Прокси-модуль (Proxy & Network)

### 9.1. Зачем он отдельный

* централизует сетевые правила
* упрощает смену провайдера прокси
* снижает связанность с конкретными источниками

### 9.2. Контракт (концептуально)

Proxy модуль предоставляет:

* `lease_proxy(profile)` → выдаёт прокси + метаданные
* `release_proxy(lease_id)` → освобождает
* `report_result(lease_id, success/fail, reason)` → учитывает качество

Профили могут отражать:

* гео
* тип источника
* уровень «агрессивности»

---

## 10. Наблюдаемость (минимально)

Для MVP важно иметь трассируемость:

* SearchJob status timeline
* какие источники опрошены
* какие ошибки были
* ссылки на Evidence (что искали и где)

Это нужно и пользователю (прозрачность), и команде (отладка).

---

## 11. Версионирование результатов

Отчёт должен быть воспроизводим:

* фиксируется набор фактов на момент сборки
* фиксируются версии правил Risk (хотя бы как номер)
* фиксируется timestamp

Это защищает от ситуации «вчера было 30, сегодня 70, почему?».

---

## 12. Минимальные требования MVP

MVP должен поддерживать:

* ввод адреса
* нормализацию адреса (ФИАС)
* запуск SearchJob
* походы в 1–3 источника через Sources Gateway + Proxy
* сохранение Facts/Evidence
* формирование RiskCard (без сложной математики)
* генерацию PDF отчёта (если включено в MVP)

Всё остальное — расширение без ломки границ.

---

## 13. Как AI-ассистенту работать с этим документом

AI должен:

* соблюдать модульные границы
* предлагать изменения через контракты (ports), а не прямые импорты
* помнить, что это modular monolith, но готовый к микросервисам
* не усложнять технологии без необходимости MVP

Если появляется новая интеграция или модуль — он добавляется как bounded context и описывается здесь.
