# Mirano — Background Jobs & Results Reuse

## 1. Назначение документа

Этот документ описывает **фоновую модель работы Mirano**: задачи (jobs), воркеры, переиспользование результатов и правила актуализации данных.

Цели:

* снизить время ожидания пользователя
* сократить нагрузку на источники
* избежать дублирования одинаковых поисков
* обеспечить воспроизводимость и масштабируемость

Фоновая обработка — **ключевая часть архитектуры Mirano**, а не оптимизация «на потом».

---

## 2. Общие принципы фоновой обработки

Mirano строит фоновые процессы вокруг следующих принципов:

* **Асинхронность по умолчанию** — пользователь не ждёт все источники
* **Idempotency first** — повтор запуска не ломает состояние
* **Reuse before fetch** — сначала ищем готовые результаты
* **Source-aware TTL** — данные устаревают по-разному
* **Прозрачность** — можно объяснить, откуда взялся результат

---

## 3. Ключевые сущности фоновой модели

### 3.1 SearchJob

**SearchJob** — агрегат, описывающий задачу поиска и проверки.

Характеристики:

* входные параметры (адрес, профиль отчёта)
* список источников
* статус выполнения
* ссылки на подзадачи

Статусы (упрощённо):

* CREATED
* IN_PROGRESS
* PARTIAL
* COMPLETED
* FAILED

---

### 3.2 SearchTask

**SearchTask** — атомарная задача обращения к конкретному источнику.

Характеристики:

* тип источника
* параметры запроса
* статус
* ссылка на используемый proxy

---

### 3.3 FactSnapshot

**FactSnapshot** — зафиксированное состояние фактов на момент отчёта.

Используется для:

* воспроизводимости отчётов
* сравнения изменений во времени

---

## 4. Поток фоновой проверки (базовый сценарий)

1. Пользователь инициирует проверку
2. Создаётся SearchJob
3. Выполняется попытка reuse существующих данных
4. Для недостающих или устаревших данных создаются SearchTask
5. Воркеры обрабатывают SearchTask
6. Результаты сохраняются как Facts + Evidence
7. Risk Engine пересчитывает risk_score
8. Report обновляет представление

Пользователь может видеть:

* прогресс по источникам
* частичный результат

---

## 5. Переиспользование результатов (Reuse)

### 5.1 Зачем нужен reuse

Без переиспользования:

* одинаковые объекты проверяются многократно
* источники перегружаются
* время ответа растёт

Reuse позволяет:

* делить результаты между пользователями
* ускорять проверки
* снижать стоимость инфраструктуры

---

### 5.2 Уровни переиспользования

1. **Property-level** — данные по объекту
2. **Developer-level** — данные по застройщику
3. **Person-level** — данные по физлицу
4. **Source-level** — результаты конкретного источника

Reuse всегда происходит **на уровне фактов**, а не готовых выводов.

---

### 5.3 Правила reuse

Перед созданием SearchTask:

* проверяется наличие релевантных Facts
* проверяется TTL источника
* проверяется соответствие параметров запроса

Если данные:

* актуальны → используются повторно
* частично актуальны → комбинируются
* устарели → создаётся новая задача

---

## 6. TTL и актуальность данных

### 6.1 TTL по типам источников (примерно)

* Судебные дела: 7–30 дней
* Исполнительные производства: 7–14 дней
* Объявления: 1–3 дня
* Отзывы: 14–30 дней

TTL — конфигурационный параметр и может меняться.

---

### 6.2 Частичное устаревание

Если устарела только часть источников:

* SearchJob получает статус PARTIAL
* пользователь видит результат + индикатор обновления

---

## 7. Фоновые обновления (Re-check)

Mirano поддерживает плановые фоновые проверки:

* периодический re-check ключевых объектов
* обновление популярных объектов
* обновление платных отчётов

Re-check:

* создаёт новые SearchTask
* не пересоздаёт SearchJob полностью
* обновляет Facts и Risk

---

## 8. Очереди и воркеры (концептуально)

### 8.1 Модель воркера

Воркер:

* берёт SearchTask
* запрашивает proxy
* обращается к источнику
* парсит результат
* сохраняет Facts/Evidence
* освобождает proxy

Ошибки:

* ретраи с backoff
* логирование причин

---

### 8.2 Идемпотентность задач

Каждый SearchTask:

* имеет уникальный ключ
* может быть выполнен повторно
* не создаёт дубликаты фактов

---

## 9. Параллелизм и ограничения

* задачи разных источников могут выполняться параллельно
* один и тот же источник может иметь лимит
* Proxy модуль участвует в rate limiting

---

## 10. Прозрачность для пользователя

Пользователь должен понимать:

* что уже проверено
* что обновляется
* насколько свежие данные

Рекомендуемые элементы UI:

* статус по источникам
* дата последнего обновления
* индикатор reuse («данные использованы из предыдущей проверки»)

---

## 11. Взаимодействие с Risk и Report

* Risk Engine пересчитывает показатели **инкрементально**
* Report обновляется по мере поступления фактов
* финальный отчёт фиксирует snapshot

---

## 12. Ограничения и честность

Mirano явно сообщает:

* что данные могут быть частично устаревшими
* что часть источников ещё в обработке
* что reuse не означает "проверили заново"

---

## 13. Расширение модели

В будущем возможно:

* приоритизация задач по ценности
* умный prefetch популярных объектов
* пользовательские уведомления об изменениях

---

## 14. Как AI-ассистент должен учитывать фоновые процессы

AI-ассистент:

* объясняет пользователю статус проверки
* корректно интерпретирует partial results
* не утверждает, что данные «только что проверены», если был reuse

---

## 15. Роль документа в chat_context

Этот файл описывает **жизнь данных во времени**.

Если возникает вопрос:

> «Почему результат пришёл быстро?» или «Почему обновление ещё идёт?»

Ответ должен начинаться здесь.
